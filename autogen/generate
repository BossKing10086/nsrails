#!/usr/bin/env ruby

require 'rubygems'
require 'active_support/inflector'

def import_classes(array)
  array.map {|x| "#import \"#{@options[:prefix]+x.classify}.h\"" }.join("\n")
end

def h(m)
  str = "#import \"NSRails.h\"\n"
  if (m[:belongs_tos].count > 0)
    str += "\n"
    str += "@class #{m[:belongs_tos].map {|x| @options[:prefix]+x.classify}.join(', ')};"
    str += "\n"
  end
  str += "\n@interface #{m[:name]} : NSRailsModel\n"
  m[:properties].each do |type, properties|
    str += "\n@property (nonatomic, strong) #{type} #{properties.map { |x| '*'+x}.join(', ')};"
  end
  str
end

def m(m)
  str = "#import \"#{m[:name]}.h\"\n"
  if (m[:X_to_ones].count > 0)
    str += import_classes(m[:X_to_ones])+"\n"
  end
  str += "\n@implementation #{m[:name]}"
  list = []
  m[:properties].values.each do |v|
    list += v
  end
  if (list.count > 0)
    str += "\n@synthesize #{list.join(', ')};"
  end
  str += "\nNSRailsSync(*"
  if (!@options[:exclude_belongs_to_flag])
    m[:belongs_tos].each do |bt_prop|
      str += ", #{bt_prop} -b"
    end
  end
  m[:has_manys].each do |hm_dict|
    hm_dict.each do |hm_prop, hm|
      str += ", #{hm_prop}:#{hm}"
    end
  end
  str += ")"
end

def header(filename)
str = "//
//  #{filename}
//  #{@options[:project]}
"
if (!@options[:author])
  str += "//  File generated by NSRails AutoGen tool on #{@time}.\n"
else
  str += "//  Created by #{@options[:author]} on #{@time}.\n"
end
if (!@options[:company])
  if (@options[:author])
    company = @options[:author]
  else
    company = "__MyCompanyName__"
  end
elsif
  company = @options[:company]
end
str += "//  Copyright (c) #{Time.now.year.to_s} #{company}. All rights reserved.
//"
end

def display_help
  this_file = File.expand_path(File.dirname(__FILE__))+"/generate"
  pwd = Dir.pwd
  
  puts "Usage:"
  puts "   #{this_file[pwd.length+1..this_file.length]} APP_PATH [options]"
  puts ""
  puts "Options for property translation:"
  puts "   --include-created-at        // Will include the created_at date property (as NSDate)"
  puts "   --include-updated-at        // Will include the updated_at date property (as NSDate)"
  puts "   --exclude-belongs-to-flag   // On properties defined in Rails as belongs_to, will exclude '-b' flag"
  puts "   --use-mutable-arrays        // Will use NSMutableArray instead of NSArray for has_many properties"
  puts ""
  puts "Options for file styling:"
  puts "   -a [--author]    -a \"Dan H\"             /* This is metadata for the headers at the"
  puts "   -p [--project]   -p \"My Project\"           top of your files. Use quotations if your"
  puts "   -c [--company]   -c \"My Company, LLC\"      argument has spaces.                   */"
  puts "   -x [--prefix]    -x NSR                 // Prefix for classes and filenames"
  puts ""
end

EXPANDED_OPTIONS = {"-a" => "--author", "-p" => "--project", "-c" => "--company", "-x" => "--prefix"}

def options_hash_for_args(args)
  if args.empty?
    return nil
  end
  options = Hash.new
  current_option = nil
  args.each do |arg|
    if arg == "-h" || arg == "--help"
      return nil
    end
    
    if !options[:path] #if path hasn't been set yet
      if (arg[arg.length] != "/"[0])
        arg += "/"
      end
      options[:path] = arg
    else
      if (current_option)
        options[current_option.to_sym] = arg
        current_option = nil
      else
        arg = EXPANDED_OPTIONS[arg] || arg
        current_option = arg[2..arg.length]

        if !EXPANDED_OPTIONS.values.include? arg
          options[current_option.to_sym] = true
          current_option = nil          
        end
      end
    end
  end
  options
end

def run_script_with_args(args)
  @options = options_hash_for_args(args)
  if (!@options)
    display_help
    return
  end
    
  project_name = @options[:path].split("/").last

  begin
    schema = File.open(@options[:path]+"db/schema.rb")
  rescue
    puts "Error: Either '#{@options[:path]}' isn't the root path to a Rails project or your db/schema.rb is misplaced."
    return
  end

  file_dir = File.expand_path(File.dirname(__FILE__))
  output_path = "#{file_dir}/#{project_name}.gen/"
  begin
    Dir.mkdir(output_path)
    puts "Making directory #{project_name}.gen/"
  rescue    
  end

  puts "Writing files to #{output_path}"

  @options[:project] ||= project_name.camelize 
  @options[:prefix] ||= ""

  @time = Time.now.strftime("%m/%d/%Y")

  models = []
  
  objc_conversions = {"integer" => "NSNumber", "float" => "NSNumber", "double" => "NSNumber", "string" => "NSString", "text" => "NSString", "datetime" => "NSDate"}
  while line = schema.gets()
    new_model = false
    if line =~ /create_table/
      new_model = true
      model_name = line.match(/create_table "(.*)",/).captures[0]
      @model = {:name => @options[:prefix]+model_name.classify, :model_name => model_name.singularize}
      @model[:properties] = Hash.new
      @model[:belongs_tos] = Array.new
      @model[:has_manys] = Array.new
      @model[:X_to_ones] = Array.new
    end
    next unless @model
    if line =~ /end/
      begin
        model_file = File.open(path+"app/models/#{@model[:model_name]}.rb")
        while line = model_file.gets()
          if (line.length > 0 && line[0] == "#"[0])
            next
          end
          match = nil

          #either "has_many :property" or "has_many :property, :through => :abc"
          #can't figure this out in regex right now so trying both...
          begin
            match = line.match(/ :(.*),/).captures
          rescue
            begin
              match = line.match(/ :(.*)/).captures
            rescue
              next
            end
          end

          prop = match[0].camelize(:lower)
          class_name = @options[:prefix]+prop.classify
          type = nil

          if line =~ /belongs_to/
            type = class_name
            @model[:belongs_tos] << prop
            @model[:X_to_ones] << prop
          elsif line =~ /has_one/
            type = class_name
            @model[:X_to_ones] << prop
          elsif line =~ /has_many/
            if (@options[:use_mutable_arrays])
              type = "NSMutableArray"
            else
              type = "NSArray"
            end
            @model[:has_manys] << {prop => class_name}
          else
            next
          end

          @model[:properties][type] ||= []
          @model[:properties][type] << prop
        end
      rescue
      end

      ["h", "m"].each do |format|
        filename = @model[:name]+"."+format
        overwrite = File.exist?(output_path+filename)
        puts "  + #{filename}#{overwrite ? '  (overwrite)' : ''}"
        File.open(output_path+filename, "w") do |file|
          file.puts(header(filename)+"\n\n")
          file.puts(eval("#{format}(@model)"))
          file.puts("\n@end")
        end
      end
      models << @model
      @model = nil
    elsif !new_model
      prop = line.match(/\"(.*?)\"/).captures[0]
      unless (prop =~ /_id/)
        if ((prop == "created_at" && !@options[:include_created_at]) ||
            (prop == "updated_at" && !@options[:include_updated_at]))
          next
        end
        
        schema_type = line.match(/t.(.*?)\"/).captures[0].strip
        prop = prop.camelize(:lower)
        type = objc_conversions[schema_type]

        @model[:properties][type] ||= []
        @model[:properties][type] << prop
      end
    end
  end
  if (models.count > 1)
    filename = @options[:prefix]+@options[:project]
    models.each do |mod|
      if mod.keys.include?(filename)
        filename += "Headers"
        break
      end
    end
    filename += ".h"
    puts "  + #{filename}"
    File.open(output_path+filename, "w") do |file|
      file.puts(header(filename)+"\n\n")
      file.puts(import_classes(models.collect { |m| m[:name] }))
    end
  end
end

run_script_with_args(ARGV)
